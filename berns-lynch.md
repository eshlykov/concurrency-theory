# Нижняя оценка на число ячеек памяти для протокола взаимного исключения.

**Теорема (Бернс, Линч).** Любой проток взаимного исключения для n потоков, построенный только на атомарных чтениях и записях, использует по крайней мере n ячеек памяти.

1. **Предположение.**

    Предположим, работают n потоков и есть протокол, который:
    * гарантирует взаимное исключение (ВИ);
    * гарантирует свободу от взаимной блокировки (СВБ);
    * использует меньше n ячеек памяти.

    Никаких других предположений нет. Докажем, что такого протокола не существует.

2. **Доказательство для n = 2.**

    Даны потоки T_1, T_2 и ячейка памяти X_1. Рассмотрим два случая:
    * Пусть поток T_1 ничего не пишет и входит в критическую секцию (СВБ). Тогда пришедший поток T_2 увидит мьютекс в исходном состоянии и также пройдет в критическую секцию. Нарушается ВИ;  
    * Пусть поток T_1 пишет что-то в ячейку X_1. Тогда пусть планировщик останавливает выполнение потока T_1 перед его первой записью в X_1. После этого пришедший поток T_2 проходит в критическую секцию (СВБ). Тогда проснувшийся поток T_1 первым действием уничтожит все следы существования потока T_2, записав свое значение в X_1. Таким образом, (по СВБ) он проходит в критическую секцию. Нарушается ВИ.

    В обоих случаях получено противоречие, следовательно, для n = 2 теорема доказана.

3. **Доказательство для n = 3.**

    Даны потоки T_1, T_2, T_3 и ячейки памяти X_1, X_2. Ясно, что каждый поток что-то пишет хотя бы в одну из ячеек памяти.

    * Рассмотрим такую конфигурацию, что T_1 и T_2 остановлены перед их первыми записями в X_1 и X_2 соответственно (без потери общности), причем ячейки X_1 и X_2 содержат начальные значения. Пусть поток T_3 проходит в критическую секцию. Далее T_1 делает свою запись в X_1, затем T_2 делает свою запись в X_2. Таким образом, стерты все следы существования потока T_3. Тогда (по СВБ) один из потоков T_1, T_2 проходит в критическую секцию. Нарушается ВИ.

    * Докажем, что описанную конфигурацию всегда можно получить. Пусть поток T_1 выполняет следующие операции:
      ```
      Lock()
      Unlock()
      Lock()
      Unlock()
      Lock()
      Unlock()
      ```
      Так как методов Lock() вызвано три, а ячеек памяти две, то по принципу Дирихле в одну из ячеек памяти первая запись осуществлена дважды. Пусть для определенности эти записи в ячейку X_1 на первой и третьей итерации.

      Остановим поток T_1 перед его первой записью в X_1 на первой итерации. Далее запускаем поток T_2: ясно, что он пишет что-то в ячейку X_2 (по доказанному для n = 2). Остановим его перед первой записью в ячейку X_2 (возможно, он при этом что-то записал в X_1!). Далее запускаем поток T_1 и останавливаем его перед первой записью в ячейку X_1 на третьей итерации. По построению это первая запись потока T_1, то есть значение X_2 начальное: был вызван метод Unlock(). Таким образом, T_1 остановлен перед первой записью в X_1, T_2 остановлен перед первой записью в X_2.

      Искомая конфигурация получена, что и доказывает теорему для n = 3.

4. **Доказательство для произвольного n.**

    Докажем утверждение индукцией по n. База рассмотрена выше. Далее везде считаем, что для меньшего, чем n, числа потоков, теорема доказана.

    Даны потоки T_1, T_2, …, T_[n+1] и ячейки памяти X_1, X_2, …, X_n. Ясно, что каждый поток что-то пишет хотя бы в одну из ячеек памяти.

    * Рассмотрим такую конфигурацию, что T_1, T_2, …, T_n остановлены перед своими первыми записями в X_1, X_2, …, X_n соответственно (без потери общности), причем ячейки X_1, X_2, …, X_n содержат начальные значения. Пусть поток T_[n+1] проходит в критическую секцию. Далее T_1 делает свою запись в X_1, затем T_2 делает свою запись в X_2, …, затем T_n делает свою запись в X_n. Таким образом, стерты все следы существования потока T_[n+1]. Тогда (по СВБ) один из потоков T_1, T_2, …, T_n проходит в критическую секцию. Нарушается ВИ.

    * Докажем, что описанную конфигурацию всегда можно получить, индукцией по числу потоков.

      **Утверждение.** Пусть 1 <= k <= n. Тогда существует конфигурация, когда T_1, T_2, …, T_k остановлены перед своими первыми записями в разные k ячеек памяти, причем все ячейки памяти содержат начальные значения.

      1. База при k = 1 очевидна.

      2. Пусть теперь k > 1. По предположению индукции возможно получить конфигурацию, когда T_1, T_2, …, T_k пишут в разные k ячеек памяти. 

          Обозначим через ConfigureThreads() последовательность операций, приводящую к такой конфигурации. Из k потоков в k ячеек памяти из n возможных существует C[n,k] различных отображений. Тогда пусть потоки выполняют следующие операции:
          ```
          ConfigureThreads()
          ConfigureThreads()
          ...
          Всего C[n,k]+1 раз.
          ```

          По принципу Дирихле найдется такие две ConfigureThreads(), которые делают одно и то же соответствие между T_1, T_2, …, T_k и k ячейками памяти. Пусть для определенности это первый и последний вызов ConfigureThreads(), а запись осуществлена в ячейки памяти X_1, X_2, …, X_k соответственно.

      3. Рассмотрим найденное выполнение операций ConfigureThreads().

          Остановим потоки в рассмотренной выше конфигурации на первой итерации. Далее запустим T_[k+1]. Ясно, что он пишет что-то в какую-то из ячеек X_[k+1], …, X_n (по предположению индукции для меньшего n). Остановим его перед первой записью в какую-то из этих ячеек. (Возможно, он при этом что-то записал в какие-то из ячеек X_1, …, X_k!) Далее запускаем наши ConfigureThreads() и останавливаем потоки перед своими первыми записями в X_1, …, X_k на последней итерации. По построению ячейки X_[k+1], …, X_n содержат начальные значения. Таким образом, потоки T_1, …, T_k, T_[k+1] остановлены перед своими первыми записями в разные k+1 ячеек памяти. Утверждение доказано.

          Значит, искомая конфигурация существует для k = n, что и доказывает теорему в общем случае.

## Замечания

* Каждый метод lock() не обязан требовать обращения ко всем n ячейкам памяти.
* Для построения противоречия мы не использовали никаких предположений о разрядности ячеек памяти.
* Доказательство работает даже для случая недетерминированного исполнения.
* Доказательство не работает, если используется операция Exchange или другая RMW-операция: с их помощью можно атомарно менять значение в ячейке памяти и читать старое значение, на основании которого делать выводы о наличии других потоков.
* Каждый ConfigureThreads() для k потоков построен с помощью C[n,k-1]+1 операций ConfigureThreads() для k-1 потоков. Таким образом, для построения «плохого исполнения» в случае n потоков используется экспоненциальное число шагов (сумма биномиальных коэффициентов).
