## Консенсус

### Наводящие соображения

Для построения lock-free структур данных мы активно использовали `CAS`. Можно ли было обойтись без него?

На второй лекции была теорема о том, что для протокола взаимного исключения на `n` потоках, использующег только `Read()` и `Write(x)`, требуется не меньше `n` ячеек памяти. Есть еще RMW-операции: `Test-And-Set(x)`, `Fetch-And-Add(x)`... Какие операции более полезны?

Что, если были бы другие операции? Например, `Memory-to-Memory-Swap(...)`, `Multi-Write(...)`, `Memory-to-Memory-Copy(...)`. Были бы они полезны в каком-то смысле?

Или, например, мы хотим wait-free очередь. Это мы ее не смогли сделать без `CAS` или это принципиально невозможно?

Для начала разберемся в терминах регистров. RW-регистр имеет две операции: `Read()` и `Write(x)`. RMW-регистр имеет дополнительно операцию `Fetch-And-Add(x)`. Как сравнить эти регистры? При этом мы абстрагируемся от их размера, содержания и прочего — все это не имеет значения. Нужна общая шкала.

### Задача консенсуса

Есть `n` потоков `T_1`, …, `T_n`. Требуется соорудить черный ящик `Consensus` с единственным методом `Decide(v)`, удовлетворяющим следующим свойствам:
* _(agreement)_ все вызовы `Decide(v)` возвращают одно и то же значение;
* _(validity)_ возвращамое значение должно быть предложено некоторым потоком;
* _(wait-free)_ каждый вызов `Decide(v)` завершается за конечное число шагов независимо от того, остановлены ли другие потоки.  

Каждый поток `T_i` выполняет следующее: `v = Consensus.Decide(v_i)`.

Пример:
```
Decide(value)
  Proposed[threadIndex] = value
  Winner = ... # Выбираем победителя
  return Proposed[Winner]
```

На самом деле задача в том, чтобы определить, какой из потоков пришел первым (на самом деле, нужно понять, куда именно поток должен придти первым; см. домашнее задание про `mem-move`).

Для построения консенсуса разрешается использовать только произвольное количество RW-регистров с операциями `Read()` и `Write()` и произвольное количество линеаризуемых объектов `X`.

Мы будем рассматривать только детерминированные исполнения.

Сила объекта `X` — это максимальное число потоков `n`, для которого существует искомый `Consensus`. Эта сила называется числом консенсуса объекта `X`.

Неочевидно, в чем смысл такого определения, почему оно полезно, и так далее. Можно доказать, что если с помощью объекта `X` можно решить задачу консенсуса для `n` потоков, с помощью этого объекта можно реализовать любой объект с гарантией wait-free. Кроме того, он будет линеаризуемым.

#### Compare and Set

```
Decide(value)
  Proposed[threadIndex] = value
  CAS(Winner, None, threadIndex)
  return Proposed[Winner]
```

Очевидно, это метод работает для сколь угодно большого числа потоков. Таким образом, `Consensus-Number(CAS) = +∞`.

### Граф конфигураций

Рассмотрим полезную конструкцию для доказательства верхних оценок на число консенсуса. В данном случае она будет применяться для доказателсьтво того, что для двух или трех потоков решения задачи консенсуса не существует.

Рассмотрим произвольный протокол консенсуса. Благодаря линеаризуемости X и атомарности регистров все обращения к памяти упорядочены. Тогда исполнение консенсуса можно представить в виде графа. В вершинах будут конфигурации. Каждая конфигурация состоит из:
1. состояние консенсуса (shared memory, heap);
1. instrudction pointer (указатель на следующую операцию, которую выполнит поток) для каждого потока;
1. локальная память каждого потока (stack).

Выполнение одной инструкции обозначается ребром от одной конфигурации к другой. Благодаря гарантии wait-free каждый вызов завершается за конечное число шагов. Таким образом, в графе нет циклов (в противном случае можно было бы бесконенчо ходить по циклу), и глубина графа конечна. Заметим, что граф в общем случае не является деревом, так как некоторые конфигурации могут сливаться в одну; тем не менее, это почти дерево, так как граф получен из него склейкой некоторых вершин (поэтому мы будем использовать термины поддерево и листья). В общем случае из одной конфигурации столько стрелок, сколько всего потоков.

Так как доказывается отрицательный результат, то задачу можно сузить, предположив, что потоки предлагают значения `0` или `1`. Если докажем невозможность консенсуса для частного случае, то для общего она будет доказана автоматически.

Введем валентные состояние вершины: `0`, если все исполнения в поддереве вернут `0`, и `1`, если все исполнения вернут `1`. Будем говорить, что в этом случае в вершине сделан выбор.

При сольном исполнении потока `A` вернется значение `0`. При сольном исполнении потока `B` вернется значение `1`. Таким образом, в корне выбор не сделан. Но в листьях, он, очевидно, совершен, поэтому существуют так называемые бивалентные вершины: в них выбор не сделан, но каждый переход из них определяет выбор. Ясно, что в их потомках обязательно возвращаются разные значения (в противном случае выбор сделан). Соответствующие конфигурации назовем критическими. Ясно, что критическая конфигурация существует для любого протокола консенсуса.

#### RW-регистры

> `Consensus-Number(RW-регистр) = 1`.

Очевидно, для одного потока задачу консенсуса можно решить. Докажем, что для двух уже нельзя. Рассмотрим критическую конфигурацию в графе конфигураций (пусть ход `A` фиксирует `0`, а ход `B` фиксирует `1`). Варианты следующий действий для потоков:

* есть чтение:

  пусть для определенности чтение делает поток `A`. Рассмотрим два случая:
  1. сначала свою операцию выполняет поток `B`. Далее он сольно исполняется до конца, таким образом, возвращается значение `1`;
  2. сначала поток `A` делает чтение. Далее поток `B` исполняется сольно до конца, таким образом, возвращается значение 0. Но для `B` отличие от прошлого случая только в локальной памяти потока `A`. Она ему неизвестна. Значит, в силу детерминированности, он должен вернуть значение `1`. Противоречие;

* запись в разные ячейки памяти:

  рассмотрим два случая:
  1. сначала поток `A` делает `X.Write(x)`, затем `B` делает `Y.Write(y)`. Тогда любые возможные исполнения вернут `0`;
  2. сначала поток `B` делает `Y.Write(y)`, затем `A` делает `X.Write(x)`. Тогда любые возможные исполнения вернут `1`. Но после сделанных двух записей мы перейдем в ту же конфигурацию, что и в первом случае, поскольку получили одинаковое состояние shared memory, указателей на следующие конфигурации и локальные памяти потоков. Таким образом, в силу детерминированности, должно вернуться значение `0`. Противоречие;

* запись в одну ячейку памяти:

  рассмотрим два случая:
  1. сначала поток `B` делает `X.write(z)` и затем сольно исполняется. Возвращается значение `1`.
  2. сначала поток `A` делает `X.write(y)`, затем поток `B` делает `X.write(z)` и сольно исполняется. Возвращется значение `0`. Но он перезапишет значение потока `A`, таким образом, в силу детерминированности, должен вернуть значение `1`. Противоречие.

_Теорема доказана._

### Класс операций Common2

Это некоторый подкласс RMW-операций. Все они выполняют следующий код:
```
X.RMW(v) atomically {
  curr = X.Read()
  X.Write(f_v(curr))
  return curr
}
```
При этом выполнены следующие условия на функции `f_v`:
1. `f_v(x) ≠ x` для некоторого `v` (чтобы исключить чтение).
2. одно из двух:
    * `f_a(f_b(x)) = f_b(f_a(x))` (коммутируют);
    * `f_a(f_b(x)) = f_a(x)` (перезаписывают).

Заметим, что в случае `f_v(x) = x + v` это операция `Fetch-And-Add(v)`, а в случае `f_v(x) = v` это `Exchange(v)`.

#### Common2-операции

> `Consensus-Number(Common2) = 2`.

Приведем решение задачи консенсуса для двух потоков.
```
Decide(value)
  Proposed[threadIndex] = value
  # В ячейке `X` начальное значение 0
  if X.RMW(1) = 0
    return Proposed[threadIndex]
  else
    return Proposed[1 - threadIndex]
```

Докажем теперь, что для трех потоков задачу консенсуса решить нельзя. Рассмотрим критическую конфигурацию в графе конфигураций (пусть ход `A` фиксирует `0`, а ход `B` фиксирует `1`). Варианты следующий действий для потоков:

* есть `Read()`:

  доказательство такое же, как в случае RW-регистров;

* есть `Write(x)`:

  эту запись можно заменить на `Exchange(x)`. Анализ будет такой же, как в случае RW-регистров;

* RMW-операции в одну ячейку и они коммутируют:

  рассмотрим два случая:
  1. сначала поток `A` делает `X.RMW(v)`, затем `B` делает `X.RMW(u)`. Затем исполняется поток `C` и возвращается значение `0`;
  2. сначала поток `B` делает `X.RMW(u)`, затем `A` делает `X.RMW(v)`. Затем исполнчется поток `C` и возвращается значение `1`. Но для потока `C` конфигурация после двух RMW-операций неотличима от конфигурации из первого случая (так как отличаются только локальные памяти потоков `A` и `B`), значит, в силу детерминированности он должен вернуть `0`. Противоречие;

* RMW-операции в одну ячейку и они перезаписывают:

  рассмотрим два случая:
  1. сначала поток `B` делает `X.RNW(u)`, затем сольно исполняется `C` и возвращается `1`.
  2. сначала поток `A` делает `X.RMW(v)`, затем `B` делает `X.RMW(u)` и перезаписывает значение. Далее сольно исполняется `C` и возвращается `0`. Но для `C` снова две конфигурации неотличимы, поэтому в силу детерминированности должно вернуться значение `1`. Противоречие;

* RMW-операции в разные ячейки памяти:

  рассмотрим два случая:
  1. сначала поток `A` делает `X.RMW(v)`, затем `B` делает `Y.RMW(u)`. Затем исполняется поток `C` и возвращается значение `0`;
  2. сначала поток `B` делает `Y.RMW(u)`, затем `A` делает `X.RMW(v)`. Затем исполняется поток `C` и возвращается значение `1`. Но для потока `C` конфигурация после двух RMW-операций неотличима от конфигурации из первого случая (так как отличаются только локальные памяти потоков `A` и `B`), значит, в силу детерминированности он должен вернуть `0`. Противоречие;

_Теорема доказана._

### Резюме

Получили wait-free иерархию:

| CN | `X`         |
|----|-------------|
| 1  | RW-регистры |
| 2  | Common2     |
| +∞ | `CAS`       |

Между 2 и +∞ очень большой зазор. Но, оказывается, между ними есть и другие операции (например, `Multi-Write` из домашнего задания).
